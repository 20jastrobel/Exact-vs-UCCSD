Compute the exact energy by diagonalizing the *same* qubit_op used by VQE; do not independently re-encode the Hamiltonian for the exact path.
"SparsePauliOp (v2.1) | IBM Quantum Documentation"
Task: Write a self-contained Python script (or notebook cell sequence) that (i) constructs the 2-site (2 spatial sites × 2 spins = 4 spin-orbitals) fermionic Hubbard Hamiltonian, (ii) maps it to a 4-qubit operator using a built-in Jordan–Wigner mapper, (iii) encodes the reference 4-qubit Hamiltonian from the provided image (transcribed below) as an explicit Pauli operator, and (iv) runs a minimal equivalence test (operator-difference norm and/or eigenvalue match) to verify the built-in JW mapping reproduces the image Hamiltonian.

Reference Hamiltonian (from image; use this exact transcription):
H = - (t/2) ( X0 X1 + Y0 Y1 + X2 X3 + Y2 Y3 )
    + (Δv/4) ( Z0 + Z2 - Z1 - Z3 )
    + (U/4) ( Z0 Z2 + Z1 Z3 )
    - (U/4) ( Z0 + Z1 + Z2 + Z3 )
    + (U/2) I.

Conventions to match the image:
- 4 fermionic modes (spin-orbitals) ordered as: 0=(site0,↑), 1=(site1,↑), 2=(site0,↓), 3=(site1,↓).
- Fermionic number operator: n_p = a†_p a_p.
- Fermionic Hamiltonian you must start from (second quantized):
  H_f = -t [a†0 a1 + a†1 a0 + a†2 a3 + a†3 a2]
        + (Δv/2)[(n1 + n3) - (n0 + n2)]
        + U [n0 n2 + n1 n3].
  (This specific sign choice on the Δv term is what yields + (Δv/4)(Z0+Z2−Z1−Z3) after JW; do not add extra constant shifts by hand.)

Implementation requirements:
1) Use Qiskit + Qiskit Nature’s built-in Jordan–Wigner mapper if available:
   - qiskit_nature.second_q.operators.FermionicOp
   - qiskit_nature.second_q.mappers.JordanWignerMapper
   - qiskit.quantum_info.SparsePauliOp (for the reference operator)
   If those imports fail, fall back to OpenFermion’s jordan_wigner, but keep the same tests.

2) Build the fermionic Hubbard operator explicitly (do not start from an already-mapped qubit Hamiltonian).
   In Qiskit Nature, create a FermionicOp with num_spin_orbitals=4 (or register_length=4 depending on version),
   using labels like:
   - hopping: "+_0 -_1", "+_1 -_0", "+_2 -_3", "+_3 -_2" with coefficient -t
   - potential: "+_1 -_1", "+_3 -_3" with +Δv/2; "+_0 -_0", "+_2 -_2" with -Δv/2
   - interaction: "+_0 -_0 +_2 -_2" and "+_1 -_1 +_3 -_3" with +U
   Then map with JordanWignerMapper().map(fermionic_op) and simplify.

3) Encode the image Hamiltonian as an explicit 4-qubit SparsePauliOp.
   Use Qiskit’s Pauli-string convention (rightmost character acts on qubit 0). With that convention:
   - X0X1 = "IIXX", Y0Y1 = "IIYY"
   - X2X3 = "XXII", Y2Y3 = "YYII"
   - Z0="IIIZ", Z1="IIZI", Z2="IZII", Z3="ZIII"
   - Z0Z2="IZIZ", Z1Z3="ZIZI"
   - I="IIII"
   Construct:
   H_ref = SparsePauliOp.from_list([
     ("IIXX", -t/2), ("IIYY", -t/2), ("XXII", -t/2), ("YYII", -t/2),
     ("IIIZ", +Δv/4), ("IZII", +Δv/4), ("IIZI", -Δv/4), ("ZIII", -Δv/4),
     ("IZIZ", +U/4), ("ZIZI", +U/4),
     ("IIIZ", -U/4), ("IIZI", -U/4), ("IZII", -U/4), ("ZIII", -U/4),
     ("IIII", +U/2),
   ]).simplify()
   (It is fine to include duplicate labels; simplify must combine them.)

4) Comparison test (“very simple algorithm”):
   - Choose multiple random numeric parameter triples (t, U, Δv) (e.g., 5–10 trials).
   - For each trial:
     a) build H_f(t,U,Δv), map to H_jw, simplify
     b) build H_ref(t,U,Δv), simplify
     c) compute diff = (H_jw - H_ref).simplify(atol=1e-12)
     d) compute a strict numeric check:
        - operator-matrix norm: ||diff||_F = np.linalg.norm(diff.to_matrix())
        - and optionally compare sorted eigenvalues of H_jw and H_ref
     e) assert the norm is < 1e-10 (or another tight tolerance), else print diff.to_list() for diagnosis.

5) Diagnostics if mismatch:
   - Print the mapped operator term list and the reference term list (sorted by Pauli label) so the mismatch is obvious.
   - If the mismatch looks like a qubit permutation, verify the fermionic mode ordering; do not “fix” by ad hoc sign flips unless you can justify it from a mode-order change.
   - If mismatch is a constant offset only, verify you used interaction U n_up n_down (unshifted) as specified above.

Deliverable:
- A single runnable Python file or notebook cell sequence that executes the tests and prints “PASS” (or raises assertion error).
- Include the reference Hamiltonian transcription (as a comment or string) so it is explicitly “encoded from the image”.
